This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-03T09:12:40.058Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/dependabot.yml
.gitignore
.run/Run Plugin.run.xml
.run/Run Tests.run.xml
.run/Run Verifications.run.xml
build-plugin.bat
build.gradle.kts
CHANGELOG.md
gradle.properties
gradle/libs.versions.toml
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
LICENSE
qodana.yml
README.md
run-plugin.bat
settings.gradle.kts
src/main/kotlin/com/thedutchservers/tabsperproject/actions/CloseFileAction.kt
src/main/kotlin/com/thedutchservers/tabsperproject/actions/RefreshTabsAction.kt
src/main/kotlin/com/thedutchservers/tabsperproject/model/Models.kt
src/main/kotlin/com/thedutchservers/tabsperproject/settings/TabsPerProjectConfigurable.kt
src/main/kotlin/com/thedutchservers/tabsperproject/settings/TabsPerProjectSettings.kt
src/main/kotlin/com/thedutchservers/tabsperproject/startup/TabsPerProjectStartupActivity.kt
src/main/kotlin/com/thedutchservers/tabsperproject/TabsPerProjectBundle.kt
src/main/kotlin/com/thedutchservers/tabsperproject/toolWindow/TabsPerProjectPanel.kt
src/main/kotlin/com/thedutchservers/tabsperproject/toolWindow/TabsPerProjectToolWindowFactory.kt
src/main/resources/icons/tabs-per-project.svg
src/main/resources/messages/MyBundle.properties
src/main/resources/messages/TabsPerProjectBundle.properties
src/main/resources/META-INF/plugin.xml
src/test/kotlin/org/jetbrains/plugins/template/MyPluginTest.kt
src/test/testData/rename/foo_after.xml
src/test/testData/rename/foo.xml

================================================================
Files
================================================================

================
File: .github/dependabot.yml
================
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file

version: 2
updates:
  - package-ecosystem: "gradle" # See documentation for possible values
    directory: "/" # Location of package manifests
    schedule:
      interval: "weekly"

================
File: .gitignore
================
.gradle
.idea
.intellijPlatform
.qodana
build

================
File: .run/Run Plugin.run.xml
================
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Run Plugin" type="GradleRunConfiguration" factoryName="Gradle">
    <log_file alias="IDE logs" path="$PROJECT_DIR$/build/idea-sandbox/*/log/idea.log" show_all="true" />
    <ExternalSystemSettings>
      <option name="executionName" />
      <option name="externalProjectPath" value="$PROJECT_DIR$" />
      <option name="externalSystemIdString" value="GRADLE" />
      <option name="scriptParameters" value="" />
      <option name="taskDescriptions">
        <list />
      </option>
      <option name="taskNames">
        <list>
          <option value="runIde" />
        </list>
      </option>
      <option name="vmOptions" value="" />
    </ExternalSystemSettings>
    <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>
    <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
    <DebugAllEnabled>false</DebugAllEnabled>
    <RunAsTest>false</RunAsTest>
    <method v="2" />
  </configuration>
</component>

================
File: .run/Run Tests.run.xml
================
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Run Tests" type="GradleRunConfiguration" factoryName="Gradle">
    <log_file alias="idea.log" path="$PROJECT_DIR$/build/idea-sandbox/system/log/idea.log" />
    <ExternalSystemSettings>
      <option name="executionName" />
      <option name="externalProjectPath" value="$PROJECT_DIR$" />
      <option name="externalSystemIdString" value="GRADLE" />
      <option name="scriptParameters" value="" />
      <option name="taskDescriptions">
        <list />
      </option>
      <option name="taskNames">
        <list>
          <option value="check" />
        </list>
      </option>
      <option name="vmOptions" value="" />
    </ExternalSystemSettings>
    <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>
    <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
    <DebugAllEnabled>false</DebugAllEnabled>
    <RunAsTest>true</RunAsTest>
    <method v="2" />
  </configuration>
</component>

================
File: .run/Run Verifications.run.xml
================
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Run Verifications" type="GradleRunConfiguration" factoryName="Gradle">
    <log_file alias="idea.log" path="$PROJECT_DIR$/build/idea-sandbox/system/log/idea.log" />
    <ExternalSystemSettings>
      <option name="executionName" />
      <option name="externalProjectPath" value="$PROJECT_DIR$" />
      <option name="externalSystemIdString" value="GRADLE" />
      <option name="scriptParameters" value="" />
      <option name="taskDescriptions">
        <list />
      </option>
      <option name="taskNames">
        <list>
          <option value="verifyPlugin" />
        </list>
      </option>
      <option name="vmOptions" value="" />
    </ExternalSystemSettings>
    <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>
    <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
    <DebugAllEnabled>false</DebugAllEnabled>
    <RunAsTest>false</RunAsTest>
    <method v="2" />
  </configuration>
</component>

================
File: build-plugin.bat
================
@echo off
echo Building Tabs Per Project Plugin...
echo.

REM Clean previous builds
echo Cleaning previous builds...
call gradlew clean

REM Build the plugin
echo Building plugin...
call gradlew buildPlugin

if %ERRORLEVEL% == 0 (
    echo.
    echo Build successful!
    echo Plugin JAR can be found in: build\distributions\
    echo.
    echo To install in your IDE:
    echo 1. Open Settings/Preferences
    echo 2. Go to Plugins
    echo 3. Click the gear icon and select "Install Plugin from Disk..."
    echo 4. Select the ZIP file from build\distributions\
) else (
    echo.
    echo Build failed! Check the error messages above.
)

pause

================
File: build.gradle.kts
================
import org.jetbrains.changelog.Changelog
import org.jetbrains.changelog.markdownToHTML
import org.jetbrains.intellij.platform.gradle.TestFrameworkType

plugins {
    id("java") // Java support
    alias(libs.plugins.kotlin) // Kotlin support
    alias(libs.plugins.intelliJPlatform) // IntelliJ Platform Gradle Plugin
    alias(libs.plugins.changelog) // Gradle Changelog Plugin
    alias(libs.plugins.qodana) // Gradle Qodana Plugin
    alias(libs.plugins.kover) // Gradle Kover Plugin
}

group = providers.gradleProperty("pluginGroup").get()
version = providers.gradleProperty("pluginVersion").get()

// Set the JVM language level used to build the project.
kotlin {
    jvmToolchain(21)
}

// Configure project's dependencies
repositories {
    mavenCentral()

    // IntelliJ Platform Gradle Plugin Repositories Extension - read more: https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-repositories-extension.html
    intellijPlatform {
        defaultRepositories()
    }
}

// Dependencies are managed with Gradle version catalog - read more: https://docs.gradle.org/current/userguide/platforms.html#sub:version-catalog
dependencies {
    testImplementation(libs.junit)
    testImplementation(libs.opentest4j)

    // IntelliJ Platform Gradle Plugin Dependencies Extension - read more: https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-dependencies-extension.html
    intellijPlatform {
        create(providers.gradleProperty("platformType"), providers.gradleProperty("platformVersion"))

        // Plugin Dependencies. Uses `platformBundledPlugins` property from the gradle.properties file for bundled IntelliJ Platform plugins.
        bundledPlugins(providers.gradleProperty("platformBundledPlugins").map { it.split(',') })

        // Plugin Dependencies. Uses `platformPlugins` property from the gradle.properties file for plugin from JetBrains Marketplace.
        plugins(providers.gradleProperty("platformPlugins").map { it.split(',') })

        testFramework(TestFrameworkType.Platform)
    }
}

// Configure IntelliJ Platform Gradle Plugin - read more: https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-extension.html
intellijPlatform {
    pluginConfiguration {
        name = providers.gradleProperty("pluginName")
        version = providers.gradleProperty("pluginVersion")

        // Extract the <!-- Plugin description --> section from README.md and provide for the plugin's manifest
        description = providers.fileContents(layout.projectDirectory.file("README.md")).asText.map {
            val start = "<!-- Plugin description -->"
            val end = "<!-- Plugin description end -->"

            with(it.lines()) {
                if (!containsAll(listOf(start, end))) {
                    throw GradleException("Plugin description section not found in README.md:\n$start ... $end")
                }
                subList(indexOf(start) + 1, indexOf(end)).joinToString("\n").let(::markdownToHTML)
            }
        }

        val changelog = project.changelog // local variable for configuration cache compatibility
        // Get the latest available change notes from the changelog file
        changeNotes = providers.gradleProperty("pluginVersion").map { pluginVersion ->
            with(changelog) {
                renderItem(
                    (getOrNull(pluginVersion) ?: getUnreleased())
                        .withHeader(false)
                        .withEmptySections(false),
                    Changelog.OutputType.HTML,
                )
            }
        }

        ideaVersion {
            sinceBuild = providers.gradleProperty("pluginSinceBuild")
            untilBuild = providers.gradleProperty("pluginUntilBuild")
        }
    }

    signing {
        certificateChain = providers.environmentVariable("CERTIFICATE_CHAIN")
        privateKey = providers.environmentVariable("PRIVATE_KEY")
        password = providers.environmentVariable("PRIVATE_KEY_PASSWORD")
    }

    publishing {
        token = providers.environmentVariable("PUBLISH_TOKEN")
        // The pluginVersion is based on the SemVer (https://semver.org) and supports pre-release labels, like 2.1.7-alpha.3
        // Specify pre-release label to publish the plugin in a custom Release Channel automatically. Read more:
        // https://plugins.jetbrains.com/docs/intellij/deployment.html#specifying-a-release-channel
        channels = providers.gradleProperty("pluginVersion").map { listOf(it.substringAfter('-', "").substringBefore('.').ifEmpty { "default" }) }
    }

    pluginVerification {
        ides {
            recommended()
        }
    }
}

// Configure Gradle Changelog Plugin - read more: https://github.com/JetBrains/gradle-changelog-plugin
changelog {
    groups.empty()
    repositoryUrl = providers.gradleProperty("pluginRepositoryUrl")
}

// Configure Gradle Kover Plugin - read more: https://github.com/Kotlin/kotlinx-kover#configuration
kover {
    reports {
        total {
            xml {
                onCheck = true
            }
        }
    }
}

tasks {
    wrapper {
        gradleVersion = providers.gradleProperty("gradleVersion").get()
    }

    publishPlugin {
        dependsOn(patchChangelog)
    }
}

intellijPlatformTesting {
    runIde {
        register("runIdeForUiTests") {
            task {
                jvmArgumentProviders += CommandLineArgumentProvider {
                    listOf(
                        "-Drobot-server.port=8082",
                        "-Dide.mac.message.dialogs.as.sheets=false",
                        "-Djb.privacy.policy.text=<!--999.999-->",
                        "-Djb.consents.confirmation.enabled=false",
                    )
                }
            }

            plugins {
                robotServerPlugin()
            }
        }
    }
}

================
File: CHANGELOG.md
================
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial release of Tabs Per Project plugin

### Security

## [1.0.0] - 2025-06-02

### Added
- Initial release of Tabs Per Project plugin
- Basic functionality for managing tabs per project

================
File: gradle.properties
================
# IntelliJ Platform Artifacts Repositories -> https://plugins.jetbrains.com/docs/intellij/intellij-artifacts.html

pluginGroup = com.thedutchservers.tabsperproject
pluginName = Tabs Per Project
pluginRepositoryUrl = https://github.com/thedutchruben/jetbrains-tabs-per-project-plugin
# SemVer format -> https://semver.org
pluginVersion = 1.0.0

# Supported build number ranges and IntelliJ Platform versions -> https://plugins.jetbrains.com/docs/intellij/build-number-ranges.html
pluginSinceBuild = 232
pluginUntilBuild = 252.*

# IntelliJ Platform Properties -> https://plugins.jetbrains.com/docs/intellij/tools-gradle-intellij-plugin.html#configuration-intellij-extension
platformType = IC
platformVersion = 2024.2.5

# Plugin Dependencies -> https://plugins.jetbrains.com/docs/intellij/plugin-dependencies.html
# Example: platformPlugins = com.jetbrains.php:203.4449.22, org.intellij.scala:2023.3.27@EAP
platformPlugins =
# Example: platformBundledPlugins = com.intellij.java
platformBundledPlugins =

# Gradle Releases -> https://github.com/gradle/gradle/releases
gradleVersion = 8.13

# Opt-out flag for bundling Kotlin standard library -> https://jb.gg/intellij-platform-kotlin-stdlib
kotlin.stdlib.default.dependency = false

# Enable Gradle Configuration Cache -> https://docs.gradle.org/current/userguide/configuration_cache.html
org.gradle.configuration-cache = true

# Enable Gradle Build Cache -> https://docs.gradle.org/current/userguide/build_cache.html
org.gradle.caching = true

================
File: gradle/libs.versions.toml
================
[versions]
# libraries
junit = "4.13.2"
opentest4j = "1.3.0"

# plugins
changelog = "2.2.1"
intelliJPlatform = "2.6.0"
kotlin = "2.1.21"
kover = "0.9.1"
qodana = "2025.1.1"

[libraries]
junit = { group = "junit", name = "junit", version.ref = "junit" }
opentest4j = { group = "org.opentest4j", name = "opentest4j", version.ref = "opentest4j" }

[plugins]
changelog = { id = "org.jetbrains.changelog", version.ref = "changelog" }
intelliJPlatform = { id = "org.jetbrains.intellij.platform", version.ref = "intelliJPlatform" }
kotlin = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
kover = { id = "org.jetbrains.kotlinx.kover", version.ref = "kover" }
qodana = { id = "org.jetbrains.qodana", version.ref = "qodana" }

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2000-2021 JetBrains s.r.o.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: qodana.yml
================
# Qodana configuration:
# https://www.jetbrains.com/help/qodana/qodana-yaml.html

version: "1.0"
linter: jetbrains/qodana-jvm-community:2024.3
projectJDK: "21"
profile:
  name: qodana.recommended
exclude:
  - name: All
    paths:
      - .qodana

================
File: README.md
================
# Tabs Per Project Plugin for JetBrains IDEs

A JetBrains plugin that groups open editor tabs by project in a convenient tool window. Perfect for developers working with multiple projects simultaneously in IntelliJ IDEA, WebStorm, **Rider** (with special .NET solution support), and other JetBrains IDEs.

<!-- Plugin description -->
This plugin helps you organize your open files by grouping them according to their project. Perfect for developers working with multiple projects simultaneously in IntelliJ IDEA, WebStorm, Rider, and other JetBrains IDEs.

## Features

- **Current window focus**: Shows only files from the current project window, not all open projects
- **Module/project grouping**: Files are grouped by their module (perfect for solutions with multiple projects like .NET solutions)
- **Rider/.NET support**: Special detection for .NET projects in Rider - properly separates .csproj/.vbproj projects instead of showing "rider.module"
- **Smart file naming**: Files with duplicate names show their parent folder for easy identification
- **Customizable project colors**: Assign colors to projects for easy visual identification
- **Flexible sorting options**: Sort files alphabetically, by last modified time, by project, or by module
- **Quick file management**: Close individual files or all files in a project with one click
- **Configurable tool window position**: Place the tool window on the left, right, or bottom of your IDE
- **Real-time updates**: The file list updates automatically as you open and close files
- **Active file highlighting**: Currently active file is highlighted with bold text and selection background
- **Modified file indicators**: Files with unsaved changes show a "*" prefix and green color
- **Hide IDE editor tabs**: Option to hide the IDE's built-in editor tabs when using this plugin
- **Clean module names**: Automatically cleans up module names (removes file extensions and common prefixes)

## Usage

1. After installation, you'll find the "Tabs Per Project" tool window on the right side of your IDE (configurable)
2. Open files from different projects and see them automatically grouped
3. Double-click a project name to assign a custom color
4. Click on any file name to switch to it
5. Use the × button to close individual files or all files in a project

## Configuration

Access the plugin settings via:
- **Windows/Linux**: File → Settings → Tools → Tabs Per Project
- **macOS**: IntelliJ IDEA → Preferences → Tools → Tabs Per Project

Available settings:
- Tool window position (left, right, bottom)
- Sort order (alphabetical, last modified, project then alphabetical, module then alphabetical)
- Show/hide project colors
- Hide IDE editor tabs (use plugin tabs only)
- Group files by module within projects (enabled by default)

<!-- Plugin description end -->

## Installation

- Using IDE built-in plugin system:
  
  <kbd>Settings/Preferences</kbd> > <kbd>Plugins</kbd> > <kbd>Marketplace</kbd> > <kbd>Search for "Tabs Per Project"</kbd> >
  <kbd>Install Plugin</kbd>
  
- Manually:

  Download the [latest release](https://github.com/yourusername/tabs-per-project/releases/latest) and install it manually using
  <kbd>Settings/Preferences</kbd> > <kbd>Plugins</kbd> > <kbd>⚙️</kbd> > <kbd>Install plugin from disk...</kbd>

## Development

This plugin is built using:
- Kotlin
- IntelliJ Platform Plugin SDK
- Gradle

To build the plugin locally:
```bash
./gradlew buildPlugin
```

To run the plugin in a sandboxed IDE:
```bash
./gradlew runIde
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

================
File: run-plugin.bat
================
@echo off
echo Running Tabs Per Project Plugin in Sandbox IDE...
echo.

call gradlew runIde

pause

================
File: settings.gradle.kts
================
rootProject.name = "Tabs per project"

plugins {
    id("org.gradle.toolchains.foojay-resolver-convention") version "1.0.0"
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/actions/CloseFileAction.kt
================
package com.thedutchservers.tabsperproject.actions

import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import com.thedutchservers.tabsperproject.TabsPerProjectBundle

class CloseFileAction(
    private val file: VirtualFile? = null,
    private val project: Project? = null
) : AnAction(
    TabsPerProjectBundle.message("action.closeFile"),
    TabsPerProjectBundle.message("action.closeFile"),
    null
) {
    override fun actionPerformed(e: AnActionEvent) {
        val targetFile = file ?: return
        val targetProject = project ?: e.project ?: return
        
        FileEditorManager.getInstance(targetProject).closeFile(targetFile)
    }
    
    override fun update(e: AnActionEvent) {
        e.presentation.isEnabled = file != null && project != null
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/actions/RefreshTabsAction.kt
================
package com.thedutchservers.tabsperproject.actions

import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.wm.ToolWindowManager
import com.thedutchservers.tabsperproject.TabsPerProjectBundle
import com.thedutchservers.tabsperproject.toolWindow.TabsPerProjectPanel

class RefreshTabsAction : AnAction(
    TabsPerProjectBundle.message("action.refresh"),
    TabsPerProjectBundle.message("action.refresh"),
    null
) {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val toolWindow = ToolWindowManager.getInstance(project).getToolWindow("TabsPerProject") ?: return
        
        val content = toolWindow.contentManager.getContent(0) ?: return
        val panel = content.component as? TabsPerProjectPanel ?: return
        
        panel.refreshFileList()
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/model/Models.kt
================
package com.thedutchservers.tabsperproject.model

import com.intellij.openapi.module.Module
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import java.awt.Color

data class ProjectFileGroup(
    val project: Project,
    val files: MutableList<OpenFileInfo>,
    var color: Color? = null,
    val moduleGroups: MutableMap<String, MutableList<OpenFileInfo>> = mutableMapOf()
)

data class OpenFileInfo(
    val file: VirtualFile,
    val project: Project,
    val module: Module? = null,
    val lastModified: Long = System.currentTimeMillis()
)

enum class SortOrder {
    ALPHABETICAL,
    LAST_MODIFIED,
    PROJECT_THEN_ALPHA,
    MODULE_THEN_ALPHA;

    override fun toString(): String {
        return when (this) {
            ALPHABETICAL -> "Alphabetical"
            LAST_MODIFIED -> "Last Modified"
            PROJECT_THEN_ALPHA -> "Project then Alphabetical"
            MODULE_THEN_ALPHA -> "Module then Alphabetical"
        }
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/settings/TabsPerProjectConfigurable.kt
================
package com.thedutchservers.tabsperproject.settings

import com.intellij.ide.ui.UISettings
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.options.Configurable
import com.intellij.openapi.project.ProjectManager
import com.intellij.openapi.ui.ComboBox
import com.intellij.openapi.util.registry.Registry
import com.intellij.openapi.wm.IdeFocusManager
import com.intellij.openapi.wm.ToolWindowManager
import com.intellij.openapi.wm.WindowManager
import com.intellij.ui.components.JBCheckBox
import com.intellij.ui.components.JBLabel
import com.intellij.util.concurrency.AppExecutorUtil
import com.intellij.util.ui.FormBuilder
import com.thedutchservers.tabsperproject.TabsPerProjectBundle
import com.thedutchservers.tabsperproject.model.SortOrder
import java.util.concurrent.TimeUnit
import javax.swing.JComponent
import javax.swing.JPanel

class TabsPerProjectConfigurable : Configurable {
    private var mySettingsComponent: TabsPerProjectSettingsComponent? = null

    override fun getDisplayName(): String = TabsPerProjectBundle.message("settings.displayName")

    override fun createComponent(): JComponent {
        mySettingsComponent = TabsPerProjectSettingsComponent()
        return mySettingsComponent!!.panel
    }

    override fun isModified(): Boolean {
        val settings = TabsPerProjectSettings.getInstance()
        val component = mySettingsComponent ?: return false

        return component.sortOrder != settings.sortOrder ||
               component.showProjectColors != settings.showProjectColors ||
               component.toolWindowPosition != settings.toolWindowPosition ||
               component.hideEditorTabs != settings.hideEditorTabs ||
               component.groupByModule != settings.groupByModule
    }

    override fun apply() {
        val settings = TabsPerProjectSettings.getInstance()
        val component = mySettingsComponent ?: return

        settings.sortOrder = component.sortOrder
        settings.showProjectColors = component.showProjectColors
        settings.toolWindowPosition = component.toolWindowPosition
        settings.hideEditorTabs = component.hideEditorTabs
        settings.groupByModule = component.groupByModule

        // Apply editor tabs visibility immediately
        applyEditorTabsVisibility(settings.hideEditorTabs)
    }

    override fun reset() {
        val settings = TabsPerProjectSettings.getInstance()
        val component = mySettingsComponent ?: return

        component.sortOrder = settings.sortOrder
        component.showProjectColors = settings.showProjectColors
        component.toolWindowPosition = settings.toolWindowPosition
        component.hideEditorTabs = settings.hideEditorTabs
        component.groupByModule = settings.groupByModule
    }

    private fun applyEditorTabsVisibility(hide: Boolean) {
        // Execute the operation on the UI thread
        ApplicationManager.getApplication().invokeLater {
            try {
                // Use Registry to control tab visibility - this is the key setting that controls tab visibility
                val registry = Registry.get("editor.tabs.show")
                registry.setValue(!hide)

                // Update the UISettings
                val uiSettings = UISettings.getInstance()

                // Note: We're no longer using reflection to set EDITOR_TAB_PLACEMENT
                // as it's not available in newer versions of the IntelliJ Platform API.
                // The registry key "editor.tabs.show" is sufficient to control tab visibility.

                // Notify the system that UI settings have changed
                uiSettings.fireUISettingsChanged()

                // Add a small delay to ensure changes are applied before refreshing UI
                AppExecutorUtil.getAppScheduledExecutorService().schedule({
                    // Update all open projects to reflect the change
                    for (project in ProjectManager.getInstance().openProjects) {
                        if (project.isDisposed) continue

                        // Force EditorsSplitters to rebuild their UI
                        IdeFocusManager.getInstance(project).doWhenFocusSettlesDown {
                            ToolWindowManager.getInstance(project).invokeLater {
                                // Trigger a layout update
                                val frame = WindowManager.getInstance().getIdeFrame(project)
                                frame?.component?.validate()
                                frame?.component?.repaint()
                            }
                        }
                    }
                }, 300, TimeUnit.MILLISECONDS)
            } catch (e: Exception) {
                // Log detailed error
                Logger.getInstance(TabsPerProjectConfigurable::class.java)
                    .warn("Failed to change editor tab visibility: ${e.message}", e)
            }
        }
    }

    override fun disposeUIResources() {
        mySettingsComponent = null
    }
}

class TabsPerProjectSettingsComponent {
    val panel: JPanel
    private val sortOrderCombo = ComboBox(SortOrder.entries.toTypedArray())
    private val showColorsCheckBox = JBCheckBox(TabsPerProjectBundle.message("settings.showProjectColors"))
    private val hideEditorTabsCheckBox = JBCheckBox(TabsPerProjectBundle.message("settings.hideEditorTabs"))
    private val groupByModuleCheckBox = JBCheckBox(TabsPerProjectBundle.message("settings.groupByModule"))
    private val positionCombo = ComboBox(arrayOf("left", "right", "bottom"))

    var sortOrder: SortOrder
        get() = sortOrderCombo.selectedItem as SortOrder
        set(value) { sortOrderCombo.selectedItem = value }

    var showProjectColors: Boolean
        get() = showColorsCheckBox.isSelected
        set(value) { showColorsCheckBox.isSelected = value }

    var hideEditorTabs: Boolean
        get() = hideEditorTabsCheckBox.isSelected
        set(value) { hideEditorTabsCheckBox.isSelected = value }
    
    var groupByModule: Boolean
        get() = groupByModuleCheckBox.isSelected
        set(value) { groupByModuleCheckBox.isSelected = value }

    var toolWindowPosition: String
        get() = positionCombo.selectedItem as String
        set(value) { positionCombo.selectedItem = value }

    init {
        panel = FormBuilder.createFormBuilder()
            .addLabeledComponent(JBLabel(TabsPerProjectBundle.message("settings.defaultPosition")), positionCombo, 1, false)
            .addLabeledComponent(JBLabel(TabsPerProjectBundle.message("settings.sortOrder")), sortOrderCombo, 1, false)
            .addComponent(showColorsCheckBox, 1)
            .addComponent(hideEditorTabsCheckBox, 1)
            .addComponent(groupByModuleCheckBox, 1)
            .addComponentFillVertically(JPanel(), 0)
            .panel
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/settings/TabsPerProjectSettings.kt
================
package com.thedutchservers.tabsperproject.settings

import com.intellij.openapi.components.*
import com.intellij.openapi.project.Project
import com.intellij.util.xmlb.XmlSerializerUtil
import com.intellij.util.xmlb.annotations.MapAnnotation
import com.thedutchservers.tabsperproject.model.SortOrder
import java.awt.Color

@State(
    name = "TabsPerProjectSettings",
    storages = [Storage("TabsPerProjectSettings.xml")]
)
@Service
class TabsPerProjectSettings : PersistentStateComponent<TabsPerProjectSettings> {
    
    var toolWindowPosition: String = "right"
    var sortOrder: SortOrder = SortOrder.MODULE_THEN_ALPHA
    var showProjectColors: Boolean = true
    var hideEditorTabs: Boolean = false
    var groupByModule: Boolean = true
    
    @MapAnnotation
    var projectColors: MutableMap<String, String> = mutableMapOf()
    
    override fun getState(): TabsPerProjectSettings = this
    
    override fun loadState(state: TabsPerProjectSettings) {
        XmlSerializerUtil.copyBean(state, this)
    }
    
    fun getProjectColor(project: Project): Color? {
        val colorHex = projectColors[project.name] ?: return null
        return try {
            Color.decode(colorHex)
        } catch (e: Exception) {
            null
        }
    }
    
    fun setProjectColor(project: Project, color: Color?) {
        if (color == null) {
            projectColors.remove(project.name)
        } else {
            projectColors[project.name] = String.format("#%06X", color.rgb and 0xFFFFFF)
        }
    }
    
    companion object {
        fun getInstance(): TabsPerProjectSettings = 
            service<TabsPerProjectSettings>()
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/startup/TabsPerProjectStartupActivity.kt
================
package com.thedutchservers.tabsperproject.startup

import com.intellij.ide.ui.UISettings
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.Project
import com.intellij.openapi.startup.ProjectActivity
import com.intellij.openapi.util.registry.Registry
import com.intellij.openapi.wm.ToolWindowAnchor
import com.intellij.openapi.wm.ToolWindowManager
import com.intellij.openapi.wm.WindowManager
import com.intellij.util.concurrency.AppExecutorUtil
import com.thedutchservers.tabsperproject.settings.TabsPerProjectSettings
import java.util.concurrent.TimeUnit

class TabsPerProjectStartupActivity : ProjectActivity {
    override suspend fun execute(project: Project) {
        ApplicationManager.getApplication().invokeLater {
            val settings = TabsPerProjectSettings.getInstance()

            // Apply editor tabs visibility setting on startup
            try {
                // Use Registry to control tab visibility
                val registry = Registry.get("editor.tabs.show")
                registry.setValue(!settings.hideEditorTabs)

                // Update the UISettings
                val uiSettings = UISettings.getInstance()

                // Notify the system that UI settings have changed
                uiSettings.fireUISettingsChanged()

                // Add a small delay to ensure changes are applied before refreshing UI
                AppExecutorUtil.getAppScheduledExecutorService().schedule({
                    // Trigger a layout update for the project
                    val frame = WindowManager.getInstance().getIdeFrame(project)
                    frame?.component?.validate()
                    frame?.component?.repaint()
                }, 300, TimeUnit.MILLISECONDS)
            } catch (e: Exception) {
                Logger.getInstance(TabsPerProjectStartupActivity::class.java)
                    .warn("Failed to apply editor tabs visibility on startup", e)
            }

            // Apply saved tool window position
            val toolWindowManager = ToolWindowManager.getInstance(project)
            val toolWindow = toolWindowManager.getToolWindow("TabsPerProject") ?: return@invokeLater

            val anchor = when (settings.toolWindowPosition) {
                "left" -> ToolWindowAnchor.LEFT
                "bottom" -> ToolWindowAnchor.BOTTOM
                "top" -> ToolWindowAnchor.TOP
                else -> ToolWindowAnchor.RIGHT
            }
            toolWindow.setAnchor(anchor, null)
        }
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/TabsPerProjectBundle.kt
================
package com.thedutchservers.tabsperproject

import com.intellij.DynamicBundle
import org.jetbrains.annotations.PropertyKey

private const val BUNDLE = "messages.TabsPerProjectBundle"

object TabsPerProjectBundle : DynamicBundle(BUNDLE) {
    @Suppress("unused")
    @JvmStatic
    fun message(@PropertyKey(resourceBundle = BUNDLE) key: String, vararg params: Any): String = 
        getMessage(key, *params)
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/toolWindow/TabsPerProjectPanel.kt
================
package com.thedutchservers.tabsperproject.toolWindow

import com.intellij.icons.AllIcons
import com.intellij.openapi.actionSystem.*
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.FileEditorManagerEvent
import com.intellij.openapi.fileEditor.FileEditorManagerListener
import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.ProjectRootManager
import com.intellij.openapi.ui.SimpleToolWindowPanel
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.ui.ColorChooserService
import com.intellij.ui.JBColor
import com.intellij.ui.ScrollPaneFactory
import com.intellij.ui.components.JBLabel
import com.intellij.ui.components.JBPanel
import com.intellij.util.ui.JBUI
import com.intellij.util.ui.UIUtil
import com.thedutchservers.tabsperproject.TabsPerProjectBundle
import com.thedutchservers.tabsperproject.actions.RefreshTabsAction
import com.thedutchservers.tabsperproject.model.OpenFileInfo
import com.thedutchservers.tabsperproject.model.ProjectFileGroup
import com.thedutchservers.tabsperproject.model.SortOrder
import com.thedutchservers.tabsperproject.settings.TabsPerProjectSettings
import java.awt.*
import java.awt.event.MouseAdapter
import java.awt.event.MouseEvent
import javax.swing.*

class TabsPerProjectPanel(private val project: Project) : SimpleToolWindowPanel(true, true) {
    private val contentPanel = JBPanel<JBPanel<*>>(VerticalFlowLayout(0, 0))
    private val fileGroups = mutableMapOf<Project, ProjectFileGroup>()
    
    init {
        setupUI()
        setupListeners()
        refreshFileList()
    }
    
    private fun setupUI() {
        val scrollPane = ScrollPaneFactory.createScrollPane(contentPanel)
        scrollPane.horizontalScrollBarPolicy = JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        scrollPane.verticalScrollBarPolicy = JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED
        
        setContent(scrollPane)
        setupToolbar()
    }
    
    private fun setupToolbar() {
        val actionGroup = DefaultActionGroup()
        actionGroup.add(RefreshTabsAction())
        
        val toolbar = ActionManager.getInstance().createActionToolbar(
            "Tabs per project",
            actionGroup,
            true
        )
        toolbar.targetComponent = this
        setToolbar(toolbar.component)
    }
    
    private fun setupListeners() {
        project.messageBus.connect().subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, object : FileEditorManagerListener {
            override fun fileOpened(source: FileEditorManager, file: VirtualFile) {
                ApplicationManager.getApplication().invokeLater {
                    refreshFileList()
                }
            }
            
            override fun fileClosed(source: FileEditorManager, file: VirtualFile) {
                ApplicationManager.getApplication().invokeLater {
                    refreshFileList()
                }
            }
            
            override fun selectionChanged(event: FileEditorManagerEvent) {
                ApplicationManager.getApplication().invokeLater {
                    refreshFileList()
                }
            }
        })
    }
    
    fun refreshFileList() {
        fileGroups.clear()
        
        // Only collect files from the current project window
        val fileEditorManager = FileEditorManager.getInstance(project)
        val openFiles = fileEditorManager.openFiles

        if (openFiles.isNotEmpty()) {
            val group = fileGroups.getOrPut(project) {
                ProjectFileGroup(
                    project,
                    mutableListOf(),
                    TabsPerProjectSettings.getInstance().getProjectColor(project)
                )
            }

            openFiles.forEach { file ->
                // Find the module for this file
                val module = ProjectRootManager.getInstance(project)
                    .fileIndex
                    .getModuleForFile(file)
                
                val fileInfo = OpenFileInfo(file, project, module)
                group.files.add(fileInfo)
                
                // Determine the actual project/module name
                val effectiveModuleName = when {
                    // Special handling for Rider with .NET solutions
                    module != null && module.name.contains("rider.module", ignoreCase = true) -> {
                        detectDotNetProject(file, project)
                    }
                    module != null -> module.name
                    else -> null
                }
                
                // Group by effective module name if it exists
                if (effectiveModuleName != null) {
                    group.moduleGroups.getOrPut(effectiveModuleName) { mutableListOf() }
                        .add(fileInfo)
                }
            }
        }
        
        // Sort files according to settings
        val settings = TabsPerProjectSettings.getInstance()
        when (settings.sortOrder) {
            SortOrder.ALPHABETICAL -> {
                fileGroups.values.forEach { group ->
                    group.files.sortBy { it.file.name.lowercase() }
                    group.moduleGroups.values.forEach { moduleFiles ->
                        moduleFiles.sortBy { it.file.name.lowercase() }
                    }
                }
            }
            SortOrder.LAST_MODIFIED -> {
                fileGroups.values.forEach { group ->
                    group.files.sortByDescending { it.lastModified }
                    group.moduleGroups.values.forEach { moduleFiles ->
                        moduleFiles.sortByDescending { it.lastModified }
                    }
                }
            }
            SortOrder.PROJECT_THEN_ALPHA -> {
                fileGroups.values.forEach { group ->
                    group.files.sortBy { it.file.name.lowercase() }
                    group.moduleGroups.values.forEach { moduleFiles ->
                        moduleFiles.sortBy { it.file.name.lowercase() }
                    }
                }
            }
            SortOrder.MODULE_THEN_ALPHA -> {
                fileGroups.values.forEach { group ->
                    // Sort files by their module group key
                    val moduleMap = mutableMapOf<OpenFileInfo, String>()
                    group.moduleGroups.forEach { (moduleName, files) ->
                        files.forEach { file ->
                            moduleMap[file] = moduleName
                        }
                    }
                    
                    group.files.sortWith(compareBy(
                        { moduleMap[it] ?: "zzz_no_module" },
                        { it.file.name.lowercase() }
                    ))
                    
                    // Also sort within module groups
                    group.moduleGroups.values.forEach { moduleFiles ->
                        moduleFiles.sortBy { it.file.name.lowercase() }
                    }
                }
            }
        }
        
        updateFileListUI()
    }
    
    private fun updateFileListUI() {
        contentPanel.removeAll()
        
        val settings = TabsPerProjectSettings.getInstance()
        
        fileGroups.entries.sortedBy { it.key.name }.forEach { (project, group) ->
            // Project header
            val headerPanel = createProjectHeader(project, group)
            contentPanel.add(headerPanel)
            
            // Show files grouped by module if enabled
            if (settings.groupByModule && group.moduleGroups.isNotEmpty()) {
                // Show files grouped by module
                group.moduleGroups.entries.sortedBy { it.key }.forEach { (moduleName, moduleFiles) ->
                    // Module sub-header
                    val moduleHeader = createModuleHeader(moduleName, moduleFiles.size)
                    contentPanel.add(moduleHeader)
                    
                    // Files in this module
                    moduleFiles.forEach { fileInfo ->
                        val filePanel = createFilePanel(fileInfo, indentLevel = 2)
                        contentPanel.add(filePanel)
                    }
                }
                
                // Show files without module
                val filesWithoutModule = group.files.filter { it.module == null }
                if (filesWithoutModule.isNotEmpty()) {
                    val noModuleHeader = createModuleHeader("No Module", filesWithoutModule.size)
                    contentPanel.add(noModuleHeader)
                    
                    filesWithoutModule.forEach { fileInfo ->
                        val filePanel = createFilePanel(fileInfo, indentLevel = 2)
                        contentPanel.add(filePanel)
                    }
                }
            } else {
                // Original behavior - just show all files under project
                group.files.forEach { fileInfo ->
                    val filePanel = createFilePanel(fileInfo)
                    contentPanel.add(filePanel)
                }
            }
            
            // Add spacing between projects
            contentPanel.add(Box.createVerticalStrut(10))
        }
        
        contentPanel.revalidate()
        contentPanel.repaint()
    }
    
    private fun createProjectHeader(project: Project, group: ProjectFileGroup): JPanel {
        val headerPanel = JBPanel<JBPanel<*>>(BorderLayout())
        headerPanel.border = JBUI.Borders.empty(5, 10, 5, 10)
        headerPanel.background = UIUtil.getPanelBackground()
        
        val titlePanel = JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT, 5, 0))
        titlePanel.isOpaque = false
        
        // Project color indicator
        if (TabsPerProjectSettings.getInstance().showProjectColors && group.color != null) {
            val colorLabel = JBLabel()
            colorLabel.preferredSize = Dimension(10, 10)
            colorLabel.isOpaque = true
            colorLabel.background = group.color
            colorLabel.border = BorderFactory.createLineBorder(JBColor.GRAY)
            titlePanel.add(colorLabel)
        }
        
        // Project name
        val projectLabel = JBLabel(project.name)
        projectLabel.font = projectLabel.font.deriveFont(Font.BOLD)
        projectLabel.toolTipText = TabsPerProjectBundle.message("tooltip.configureColor")
        titlePanel.add(projectLabel)
        
        // File count
        val countLabel = JBLabel("(${group.files.size})")
        countLabel.foreground = JBColor.GRAY
        titlePanel.add(countLabel)
        
        // Add click listener for color configuration
        projectLabel.addMouseListener(object : MouseAdapter() {
            override fun mouseClicked(e: MouseEvent) {
                if (e.button == MouseEvent.BUTTON1 && e.clickCount == 2) {
                    val newColor = ColorChooserService.instance.showDialog(
                        headerPanel,
                        "Choose Project Color",
                        group.color ?: JBColor.BLUE
                    )
                    if (newColor != null) {
                        TabsPerProjectSettings.getInstance().setProjectColor(project, newColor as Color?)
                        refreshFileList()
                    }
                }
            }
        })
        
        headerPanel.add(titlePanel, BorderLayout.WEST)
        
        // Close all button
        val closeAllButton = JButton("×")
        closeAllButton.toolTipText = TabsPerProjectBundle.message("action.closeAll")
        closeAllButton.preferredSize = Dimension(20, 20)
        closeAllButton.addActionListener {
            closeAllFilesInProject(project)
        }
        headerPanel.add(closeAllButton, BorderLayout.EAST)
        
        return headerPanel
    }
    
    private fun createModuleHeader(moduleName: String, fileCount: Int): JPanel {
        val headerPanel = JBPanel<JBPanel<*>>(BorderLayout())
        headerPanel.border = JBUI.Borders.empty(3, 30, 3, 10)  // Indented more than project
        headerPanel.background = UIUtil.getPanelBackground()
        
        val titlePanel = JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT, 5, 0))
        titlePanel.isOpaque = false
        
        // Module icon
        val moduleIcon = AllIcons.Nodes.Module
        val iconLabel = JBLabel(moduleIcon)
        titlePanel.add(iconLabel)
        
        // Module name - clean up common patterns for better display
        val displayName = cleanModuleName(moduleName, project.name)
        val moduleLabel = JBLabel(displayName)
        moduleLabel.font = moduleLabel.font.deriveFont(Font.ITALIC)
        titlePanel.add(moduleLabel)
        
        // File count
        val countLabel = JBLabel("($fileCount)")
        countLabel.foreground = JBColor.GRAY
        titlePanel.add(countLabel)
        
        headerPanel.add(titlePanel, BorderLayout.WEST)
        
        return headerPanel
    }
    
    private fun createFilePanel(fileInfo: OpenFileInfo, indentLevel: Int = 1): JPanel {
        val filePanel = JBPanel<JBPanel<*>>(BorderLayout())
        val leftIndent = if (indentLevel == 2) 40 else 20
        filePanel.border = JBUI.Borders.empty(2, leftIndent, 2, 10)
        
        val fileEditorManager = FileEditorManager.getInstance(fileInfo.project)
        val isActive = fileEditorManager.selectedFiles.contains(fileInfo.file)
        val isModified = fileEditorManager.isFileOpen(fileInfo.file) && 
                        fileEditorManager.getEditors(fileInfo.file).any { editor ->
                            editor.isModified
                        }
        
        // Set background based on file state
        filePanel.background = when {
            isActive -> UIUtil.getListSelectionBackground(true)
            else -> UIUtil.getListBackground()
        }
        
        // Check if we need to show parent folder for disambiguation
        val needsParentFolder = fileGroups.values.any { group ->
            group.files.count { it.file.name == fileInfo.file.name } > 1
        }
        
        // File name label with state indicators
        val fileName = buildString {
            if (isModified) append("* ")
            if (needsParentFolder && fileInfo.file.parent != null) {
                append(fileInfo.file.parent.name)
                append("/")
            }
            append(fileInfo.file.name)
        }
        val fileLabel = JBLabel(fileName)
        fileLabel.toolTipText = buildString {
            append(fileInfo.file.path)
            if (isActive) append(" [Active]")
            if (isModified) append(" [Modified]")
        }
        fileLabel.cursor = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR)
        
        // Apply styling based on state
        if (isActive) {
            fileLabel.font = fileLabel.font.deriveFont(Font.BOLD)
        }
        if (isModified) {
            fileLabel.foreground = JBColor(Color(0, 100, 0), Color(100, 200, 100))
        }
        
        // Make clickable to open file
        fileLabel.addMouseListener(object : MouseAdapter() {
            override fun mouseClicked(e: MouseEvent) {
                if (e.button == MouseEvent.BUTTON1) {
                    FileEditorManager.getInstance(fileInfo.project).openFile(fileInfo.file, true)
                }
            }
            
            override fun mouseEntered(e: MouseEvent) {
                if (!isActive) {
                    filePanel.background = UIUtil.getListSelectionBackground(false)
                }
            }
            
            override fun mouseExited(e: MouseEvent) {
                if (!isActive) {
                    filePanel.background = UIUtil.getListBackground()
                }
            }
        })
        
        filePanel.add(fileLabel, BorderLayout.CENTER)
        
        // Close button
        val closeButton = JButton("×")
        closeButton.toolTipText = TabsPerProjectBundle.message("tooltip.closeFile")
        closeButton.preferredSize = Dimension(16, 16)
        closeButton.font = closeButton.font.deriveFont(10f)
        closeButton.addActionListener {
            FileEditorManager.getInstance(fileInfo.project).closeFile(fileInfo.file)
        }
        
        filePanel.add(closeButton, BorderLayout.EAST)
        
        return filePanel
    }
    
    private fun closeAllFilesInProject(project: Project) {
        val fileEditorManager = FileEditorManager.getInstance(project)
        fileGroups[project]?.files?.forEach { fileInfo ->
            fileEditorManager.closeFile(fileInfo.file)
        }
    }
    
    private fun detectDotNetProject(file: VirtualFile, project: Project): String? {
        val projectPath = project.basePath ?: return null
        val filePath = file.path
        
        // Find the relative path from project root
        if (!filePath.startsWith(projectPath)) {
            return null
        }
        
        val relativePath = filePath.substring(projectPath.length).replace('\\', '/')
        val pathParts = relativePath.trim('/').split('/')
        
        // Look for common .NET project patterns
        // Usually: /src/ProjectName/... or /ProjectName/...
        for (i in pathParts.indices) {
            val part = pathParts[i]
            
            // Check if this directory contains a project file
            val potentialProjectDir = project.baseDir
            var currentDir = potentialProjectDir
            
            for (j in 0..i) {
                currentDir = currentDir?.findChild(pathParts[j])
                if (currentDir == null) break
            }
            
            if (currentDir != null) {
                // Look for project files in this directory
                val projectFiles = currentDir.children.filter { child ->
                    !child.isDirectory && (
                        child.name.endsWith(".csproj") ||
                        child.name.endsWith(".vbproj") ||
                        child.name.endsWith(".fsproj")
                    )
                }
                
                if (projectFiles.isNotEmpty()) {
                    // Use the project file name without extension as the module name
                    return projectFiles.first().nameWithoutExtension
                }
            }
        }
        
        // Fallback: try to guess from path structure
        // Common patterns: src/lib/ProjectName, src/web/ProjectName
        if (pathParts.size >= 3) {
            when {
                pathParts[0] == "src" && pathParts.size > 2 -> return pathParts[2]
                pathParts[0] == "test" && pathParts.size > 1 -> return pathParts[1]
                pathParts.size > 1 -> return pathParts[0]
            }
        }
        
        return null
    }
    
    private fun cleanModuleName(moduleName: String, projectName: String): String {
        var cleanName = moduleName
            .removeSuffix(".csproj")
            .removeSuffix(".vbproj")
            .removeSuffix(".fsproj")
        
        // Remove project name prefix if present (e.g., "WebShop.Data" -> "Data")
        val projectPrefix = projectName.replace(" ", "")
        if (cleanName.startsWith("$projectPrefix.", ignoreCase = true)) {
            cleanName = cleanName.substring(projectPrefix.length + 1)
        }
        
        return cleanName
    }
}

// Custom layout for vertical stacking
private class VerticalFlowLayout(private val hgap: Int, private val vgap: Int) : LayoutManager {
    override fun addLayoutComponent(name: String?, comp: Component?) {}
    override fun removeLayoutComponent(comp: Component?) {}
    
    override fun preferredLayoutSize(parent: Container): Dimension {
        synchronized(parent.treeLock) {
            val insets = parent.insets
            var height = insets.top + insets.bottom
            var width = 0
            
            for (i in 0 until parent.componentCount) {
                val comp = parent.getComponent(i)
                if (comp.isVisible) {
                    val d = comp.preferredSize
                    height += d.height + vgap
                    width = maxOf(width, d.width)
                }
            }
            
            return Dimension(width + insets.left + insets.right + hgap * 2, height)
        }
    }
    
    override fun minimumLayoutSize(parent: Container): Dimension = preferredLayoutSize(parent)
    
    override fun layoutContainer(parent: Container) {
        synchronized(parent.treeLock) {
            val insets = parent.insets
            val maxWidth = parent.width - insets.left - insets.right - hgap * 2
            var y = insets.top
            
            for (i in 0 until parent.componentCount) {
                val comp = parent.getComponent(i)
                if (comp.isVisible) {
                    val d = comp.preferredSize
                    comp.setBounds(insets.left + hgap, y, maxWidth, d.height)
                    y += d.height + vgap
                }
            }
        }
    }
}

================
File: src/main/kotlin/com/thedutchservers/tabsperproject/toolWindow/TabsPerProjectToolWindowFactory.kt
================
package com.thedutchservers.tabsperproject.toolWindow

import com.intellij.openapi.project.Project
import com.intellij.openapi.wm.ToolWindow
import com.intellij.openapi.wm.ToolWindowFactory
import com.intellij.ui.content.ContentFactory

class TabsPerProjectToolWindowFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val contentFactory = ContentFactory.getInstance()
        val tabsPerProjectPanel = TabsPerProjectPanel(project)
        val content = contentFactory.createContent(tabsPerProjectPanel, "", false)
        toolWindow.contentManager.addContent(content)
    }
}

================
File: src/main/resources/icons/tabs-per-project.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 13 13">
  <g fill="none" fill-rule="evenodd">
    <rect width="11" height="3" x="1" y="1" fill="#6E6E6E" rx="1"/>
    <rect width="11" height="3" x="1" y="5" fill="#6E6E6E" rx="1"/>
    <rect width="11" height="3" x="1" y="9" fill="#6E6E6E" rx="1"/>
    <circle cx="2.5" cy="2.5" r="0.5" fill="#FFF"/>
    <circle cx="2.5" cy="6.5" r="0.5" fill="#FFF"/>
    <circle cx="2.5" cy="10.5" r="0.5" fill="#FFF"/>
  </g>
</svg>

================
File: src/main/resources/messages/MyBundle.properties
================
projectService=Project service: {0}
randomLabel=The random number is: {0}
shuffle=Shuffle

================
File: src/main/resources/messages/TabsPerProjectBundle.properties
================
pluginName=Tabs Per Project
toolWindow.title=Tabs Per Project
settings.displayName=Tabs Per Project
settings.defaultPosition=Default Tool Window Position
settings.sortOrder=Sort Order
settings.sortOrder.alphabetical=Alphabetical
settings.sortOrder.lastModified=Last Modified
settings.sortOrder.projectThenAlpha=Project then Alphabetical
settings.showProjectColors=Show Project Colors
settings.hideEditorTabs=Hide IDE Editor Tabs (use plugin tabs only)
settings.groupByModule=Group files by module within projects
settings.projectColors=Project Colors
action.refresh=Refresh
action.closeFile=Close File
action.closeAll=Close All Files in Project
tooltip.closeFile=Close this file
tooltip.openFile=Click to open file
tooltip.configureColor=Click to configure project color

================
File: src/main/resources/META-INF/plugin.xml
================
<!-- Plugin Configuration File. Read more: https://plugins.jetbrains.com/docs/intellij/plugin-configuration-file.html -->
<idea-plugin>
    <id>com.thedutchservers.tabsperproject</id>
    <name>Tabs Per Project</name>
    <vendor>Ruben de Roos</vendor>

    <description><![CDATA[
      Groups open editor tabs by project in a convenient tool window.<br/>
      <br/>
      Perfect for developers working with multiple projects, especially Rider users with .NET solutions!<br/>
      <br/>
      Features:<br/>
      • Groups open files by their project/module<br/>
      • Special support for Rider and .NET solutions<br/>
      • Smart file naming (shows parent folder for duplicates)<br/>
      • Customizable project colors<br/>
      • Configurable sorting options<br/>
      • Quick file closing functionality<br/>
      • Tool window position configuration<br/>
    ]]></description>

    <!-- Product and plugin compatibility requirements -->
    <depends>com.intellij.modules.platform</depends>

    <resource-bundle>messages.TabsPerProjectBundle</resource-bundle>

    <extensions defaultExtensionNs="com.intellij">
        <toolWindow factoryClass="com.thedutchservers.tabsperproject.toolWindow.TabsPerProjectToolWindowFactory"
                    id="TabsPerProject"
                    anchor="right"
                    icon="/icons/tabs-per-project.svg"/>
        
        <applicationService serviceImplementation="com.thedutchservers.tabsperproject.settings.TabsPerProjectSettings"/>
        <applicationConfigurable instance="com.thedutchservers.tabsperproject.settings.TabsPerProjectConfigurable"
                                 id="TabsPerProject"
                                 displayName="Tabs Per Project"/>
        
        <postStartupActivity implementation="com.thedutchservers.tabsperproject.startup.TabsPerProjectStartupActivity" />
    </extensions>

    <actions>
        <action id="TabsPerProject.RefreshTabs"
                class="com.thedutchservers.tabsperproject.actions.RefreshTabsAction"
                text="Refresh Tabs"
                description="Refresh the tabs list"
                icon="AllIcons.Actions.Refresh"/>
        
        <action id="TabsPerProject.CloseFile"
                class="com.thedutchservers.tabsperproject.actions.CloseFileAction"
                text="Close File"
                description="Close the selected file"
                icon="AllIcons.Actions.Close"/>
    </actions>
</idea-plugin>

================
File: src/test/kotlin/org/jetbrains/plugins/template/MyPluginTest.kt
================
package org.jetbrains.plugins.template

import com.intellij.ide.highlighter.XmlFileType
import com.intellij.openapi.components.service
import com.intellij.psi.xml.XmlFile
import com.intellij.testFramework.TestDataPath
import com.intellij.testFramework.fixtures.BasePlatformTestCase
import com.intellij.util.PsiErrorElementUtil
import org.jetbrains.plugins.template.services.MyProjectService

@TestDataPath("\$CONTENT_ROOT/src/test/testData")
class MyPluginTest : BasePlatformTestCase() {

    fun testXMLFile() {
        val psiFile = myFixture.configureByText(XmlFileType.INSTANCE, "<foo>bar</foo>")
        val xmlFile = assertInstanceOf(psiFile, XmlFile::class.java)

        assertFalse(PsiErrorElementUtil.hasErrors(project, xmlFile.virtualFile))

        assertNotNull(xmlFile.rootTag)

        xmlFile.rootTag?.let {
            assertEquals("foo", it.name)
            assertEquals("bar", it.value.text)
        }
    }

    fun testRename() {
        myFixture.testRename("foo.xml", "foo_after.xml", "a2")
    }

    fun testProjectService() {
        val projectService = project.service<MyProjectService>()

        assertNotSame(projectService.getRandomNumber(), projectService.getRandomNumber())
    }

    override fun getTestDataPath() = "src/test/testData/rename"
}

================
File: src/test/testData/rename/foo_after.xml
================
<root>
    <a2>Foo</a2>
</root>

================
File: src/test/testData/rename/foo.xml
================
<root>
    <a<caret>1>Foo</a1>
</root>
